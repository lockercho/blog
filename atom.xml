<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PY 部落格</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-26T22:13:20.765Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Pei-Ya Chiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Observability 三本柱之 Distributed Tracing 介紹</title>
    <link href="http://yoursite.com/2020/07/26/distributed-tracing-1/"/>
    <id>http://yoursite.com/2020/07/26/distributed-tracing-1/</id>
    <published>2020-07-26T19:42:46.000Z</published>
    <updated>2020-07-26T22:13:20.765Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作中使用到了 <strong>Distributed Tracing</strong>（分散式追蹤），發現 Distributed Tracing 對於 Microservices 的維護與開發是非常好用且重要的技術。</p><p>雖然 <strong>Logging</strong>、<strong>Metrics</strong> 及 <strong>Distributed Tracing</strong> 被並稱為 <a href="https://www.scalyr.com/blog/three-pillars-of-observability/" target="_blank" rel="noopener">Observability 三本柱</a>，Distributed Tracing 得到的關注度卻不如前兩者。原因可能是 Logging 與 Metric 在 Monolith System 中即被大量使用，Distributed Tracing 卻是建立在 Microservice 前提之下，普及度自然比不上前兩者。</p><p>而這段時間在學習與實作 Distributed Tracing 時，也發現繁體中文的相關資料有點少，因此決定寫個系列文介紹 Distributed Tracing，也當作是自己的工作筆記。</p><h2 id="何謂-Distributed-Tracing？"><a class="header-anchor" href="#何謂-Distributed-Tracing？"></a>何謂 Distributed Tracing？</h2><p><strong><code>Distributed Tracing</code></strong>，簡單的來說就是在監控 request 在 distributed system 或是 microservices 中的行為的技術。一個 <strong><code>Trace</code></strong>（追蹤）是用來描述網路服務在回應一個 request 時觸發的一系列事件，這些事件可能跨越了不同 process 、network boundary 或是 subsystem boundary。</p><p><strong>&quot;Distributed&quot;</strong> Tracing 為何重要？以往在 Monolith System 架構時，只要在 log 中記錄好相關的 request-id，就能從 logging system 中監控與分析每個 request 的狀況。而在 microservice 的架構中，一個服務往往背後會用到多個不同的子服務，這時若沒有對記錄下來的 log 做額外處理，logging system 會失去同個 request 在不同服務之間的連結。</p><p>Distributed Tracing 就是為了解決此問題而誕生的。</p><h2 id="觀念介紹"><a class="header-anchor" href="#觀念介紹"></a>觀念介紹</h2><p>在 Distributed Tracing 中，<strong>一個 <code>Trace</code> 描述了一個 request 在多個子服務中的不同階段分別觸發的一至多個 event</strong>。為了記錄事件在跨服務間的從屬關係以及發生順序， Distributed Tracing 規範了一系列的 headers（以 HTTP 為主，但也有 queue 與 RPC 的實作），每個子服務必須要乖乖收集這些 headers，並在對子服務送 request 時一路 propagate （傳遞）給所有子服務。</p><p><strong><code>Trace</code></strong>（追蹤）與 <strong><code>Span</code></strong>（跨度，中文好像很少用到這個詞）是 Distributed Tracing 裡最重要的兩個元件。每個 Span 還會帶有一個 <strong><code>SpanContext</code></strong> 描述 Span 之間共用的狀態。</p><h3 id="Trace"><a class="header-anchor" href="#Trace"></a>Trace</h3><p><strong><code>Trace</code></strong> 用來描述一個 request，由一到多個  <strong><code>Span</code></strong> 組成。</p><h3 id="Span"><a class="header-anchor" href="#Span"></a>Span</h3><p><strong><code>Span</code></strong> 為在各服務中發生的多個不同階段的資訊，一個 Span 包含了以下資料：</p><ul><li>事件名稱</li><li>開始與結束時間</li><li>Attributes（屬性）：一系列的 key-value</li><li>零到多個事件資料，每個事件也會包含自己的 Name, Timestamp 及 Attributes</li><li>Parent Span ID</li><li>連結到零或多個 Span</li><li>SpanContext ID</li></ul><h3 id="SpanContext"><a class="header-anchor" href="#SpanContext"></a>SpanContext</h3><p><strong><code>SpanContext</code></strong> 中包含了識別 Span 的資訊，也負責傳遞 parent span 設定的 options。</p><ul><li><strong>Trace ID</strong>：Trace 的 ID，為隨機產生的 16 bytes 值，用來 group 跨越服務邊界的所有屬於同個 Trace 的 Spans。</li><li><strong>Span ID</strong>：Span 的 ID，為隨機產生的 8 bytes 值，用來識別 Span。當 SpanID 被傳遞至子 Span 時，SpanID 會成為子 Span 中的 Parent Span ID。</li><li><strong>TraceFlags</strong>：Trace 的 options。，為 1 byte 值（含 8 bit），目前只定義了 Sampling Bit (0x1)，代表此 Trace 是否有被 sample（取樣）到。</li><li><strong>TraceState</strong>：TraceState 讓 vendor 能夾帶自行定義的 key-value pairs，能用來彈性的傳遞額外的資訊或是處理 legacy field。</li></ul><h2 id="Trace-範例"><a class="header-anchor" href="#Trace-範例"></a>Trace 範例</h2><p>假設有一個服務由 5 個子服務組成，服務間使用 RPC （Remote Procedure Call）溝通，架構如下圖：</p><div style="text-align:center;padding: 20px 0;"><figure class="image"><img style="width:50%;margin-bottom:22px;" src="/blog/2020/07/26/distributed-tracing-1/services.png">  <figcaption>Figure 1. Example distributed system</figcaption></figure></div><p>要為這個服務設計 Distributed Tracing，最簡單的方式就是對每個子服務產生一個 Span，每次 Request 會得到 1 個 Trace，Trace 中包含了 5 個。</p><p>Distributed Tracing 中有主要有兩種視覺化的方式：<strong>Directed Acyclic Graph (DAG)</strong> 或是 <strong>Time-based Gragh</strong>。</p><h3 id="DAG-View-of-Trace"><a class="header-anchor" href="#DAG-View-of-Trace"></a>DAG View of Trace</h3><p>Trace 也可以被理解為由多個 Span 組成的有向無環圖（Directed acyclic graph，簡稱 DAG），如下圖：</p><div style="text-align:center;width:100%;"><figure class="image"><img style="width:50%;margin-bottom:0px;" src="/blog/2020/07/26/distributed-tracing-1/span-DAG.png">  <figcaption>Figure 2. DAG View of a Trace </figcaption></figure></div><p>主服務 A 收到 request 時，request header 會帶有一個在系統中唯一的 TraceID，這個 TraceID 可以在服務的 Infrastructure 層產生（例如在 K8S 中可以使用 <a href="https://istio.io/latest/docs/tasks/observability/distributed-tracing/overview/" target="_blank" rel="noopener">Istio 來注入</a>）。若 TraceID 不存於 request 中，則 A 需自行產生一個 ID。TraceID 及其他的資訊（Metadata）會以 key-value 的形式存在 SpanContext 中。系統中所有子服務在溝通時必須傳遞同一個 SpanContext 至下一個服務。</p><p>一個服務可以根據需要自行產生多個 Span 以標註程式中不同的階段。但根據目前最主流的分散式追蹤的工具 OpenTelemetry 的實作，當 Trace 跨越服務邊界時，必須產生新的 Span，也就是同個 Span 是不能跨越服務邊界的（服務邊界包含了 process boundary, network 等等）</p><h3 id="Time-based-View-of-Trace"><a class="header-anchor" href="#Time-based-View-of-Trace"></a>Time-based View of Trace</h3><p>除了 DAG 圖以外，Span 也經常被視覺化在時間軸上，如下圖：</p><div style="text-align:center;width:100%;"><figure class="image"><img style="width:70%;margin-bottom:0px;" src="/blog/2020/07/26/distributed-tracing-1/sync-services.png">  <figcaption>Figure 4. Time-based View of Trace - 同步取用 D, E </figcaption></figure></div><p>以時間軸顯示 trace 時，可以很清楚地看出 request 在每個子系統中被處理的先後順序與花費時間，進而對潛在的優化方式提供 insight。</p><p>以 B 服務為例，若改以非同步（asynchronous）取用 D, E 服務，能夠有效縮短 b 的 duration，進而縮短整體 a 的 duration，如下圖：</p><div style="text-align:center;width:100%;"><figure class="image"><img style="width:70%;margin-bottom:0px;" src="/blog/2020/07/26/distributed-tracing-1/async-services.png">  <figcaption>Figure 5. Time-based View of Trace - 非同步取用 D, E </figcaption></figure></div><p>一般而言，Time-based 的視覺化會比 DAG 更常用到，也是 <a href="https://www.jaegertracing.io/docs/1.18/" target="_blank" rel="noopener">Jaeger</a> 這個 Trace 收集系統預設的視覺化方式。</p><h2 id="Sample（取樣）"><a class="header-anchor" href="#Sample（取樣）"></a>Sample（取樣）</h2><p>雖然分散式追蹤產生一個 Span 的延遲極低（nano second 等級），但是對於跨多個子服務的高併發低延遲服務，開啟 Tracing 能造成的 Performance Impact 依然是很可觀的。因此實務上來說不一定會記錄所有 Request 的 Trace，而是使用 Sample（取樣）的機制選擇性記錄。</p><p>下面表格是 Google 在 2010 提出的 paper <a href="https://research.google/pubs/pub36356/" target="_blank" rel="noopener">“Dapper, a Large-Scale Distributed Systems Tracing Infrastructure”</a> （強烈推薦閱讀原文，此 paper 定義了現代 Distributed Tracing 架構）中，對於當時內部使用的分散式追蹤工具 Dapper 所做的效能測試：</p><div style="text-align:center;width:100%;"><figure class="image"><img style="width:50%;margin-bottom:0px;" src="/blog/2020/07/26/distributed-tracing-1/tracing-perf.png">  <figcaption>Table 1. Performance Benchmark of Dapper </figcaption></figure></div><p>在這個測試中，Google 對自家的搜尋引擎 API 加上 Distributed Tracing，並設定不同的 Sampling frequency（取樣頻率）來觀察效能影響。在 Sampling rate 為 1 時（意即記錄所有 Requests 的 trace ），平均 latency 增加了 <strong>16.3%</strong> 之多，之後 Latency change % 隨著 Sampling Rate 降低而降低。而根據 paper 的說明，把 Sampling rate 降至 <strong>1/16</strong> 以下後，Tracing 對效能造成的影響就沒有那麼顯著了。（另外，Paper 中也提到了 Latency 與 Throughput 的實驗誤差個別是 2.5% 及 0.15%，這也是為什麼表格中的 Latency change % 在 Sampling rate = 1/1024 時會是負的。）</p><h3 id="Sampling-Rate-設定多少好？"><a class="header-anchor" href="#Sampling-Rate-設定多少好？"></a>Sampling Rate 設定多少好？</h3><p>這個效能測試的結果是否代表我們不該使用 Sampling Rate = 1 呢？我認為不是。前面也提到了產生一個 Span 只需要幾 nano second 而已，而 Google 的實驗結果對 latency 影響如此顯著，我想背後可能原因為：</p><ol><li>Google 搜尋 API 原本效能就很好，延遲很低，所以算出來的 change  % 就會比較高。</li><li>此 API 的背後可能通過了很多個子服務，因此會產生很多 span，增加了較多 latency。</li></ol><p>Sampling Rate 應該設為多少？這個問題必須依據你的系統架構、效能需求以及使用情境來決定。但不變的真理是：<strong>Benchmark 是好物</strong>，在決定 Sampling Rate 前最好搭配適當的效能測試、取得數據來幫助決策。</p><h3 id="如何實作-Distributed-Tracing？"><a class="header-anchor" href="#如何實作-Distributed-Tracing？"></a>如何實作 Distributed Tracing？</h3><p>要對所有跨服務的 Request 增加額外的 Header 其實是滿辛苦的工作，首先不同子服務之間不一定是用一樣的 protocol 溝通，目前比較流行的方式就有 HTTP、gRPC 或是 Message Queue。且若是一個子服務實作 Tracing 時不小心寫了 bug 而沒有正確傳遞 Header，整個 Trace - Span 的結構就會中斷。</p><p>由於 Distributed Tracing 的條件是如此嚴格，早在 2010 年以前分散式追蹤還是 Google 自己的內部專案時，就習慣把 Tracing（Header 收集與傳遞）實作在 Web Framework 或 Library level（稱為 “instrument”），使用者只要在跟子服務互動時使用 instrumented library 就能完成 Tracing。而後來 Open Source 社群的實作，不管是 OpenTracing、OpenConsensus 到最近的 OpenTelemetry，都會直接對較流行的程式語言以及該語言主流的 Web framework、Request library 實作相關的 instrumented library。</p><p>簡單一句總結就是：先找現有的 Tracing library 來用（並且有很大的機會你可以找到！）</p><h2 id="小結"><a class="header-anchor" href="#小結"></a>小結</h2><p>Distributed Tracing 是很好用的技術，筆者曾經使用它來找到不少 API 的效能瓶頸，直觀的視覺化方式也能幫助團隊成員快速理解自家服務的運作。</p><p>雖然 Distributed Tracing 以往得到的關注度不如 Logging 與 Metrics，但近年由於 Docker、Kubernetes 技術的普及，microservices 也幾乎是網路服務的預設架構了，相信之後 Distributed Tracing 也會漸漸的成為 microservice cluster 中的必備定番。</p><h2 id="參考資料"><a class="header-anchor" href="#參考資料"></a>參考資料</h2><ul><li>OpenTelemetry Specification:<br><a href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md" target="_blank" rel="noopener">https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md</a></li><li>“Dapper, a Large-Scale Distributed Systems Tracing Infrastructure”(Google Paper):<br><a href="https://research.google/pubs/pub36356/" target="_blank" rel="noopener">https://research.google/pubs/pub36356/</a></li><li>Istio Distributed Tracing Overview:<br><a href="https://istio.io/latest/docs/tasks/observability/distributed-tracing/overview/" target="_blank" rel="noopener">https://istio.io/latest/docs/tasks/observability/distributed-tracing/overview/</a></li><li>Jaeger - A Distributed Tracing System:<br><a href="https://www.jaegertracing.io/docs/1.18/" target="_blank" rel="noopener">https://www.jaegertracing.io/docs/1.18/</a></li><li>Three Pillars of Observability:<br><a href="https://www.scalyr.com/blog/three-pillars-of-observability/" target="_blank" rel="noopener">https://www.scalyr.com/blog/three-pillars-of-observability/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在工作中使用到了 &lt;strong&gt;Distributed Tracing&lt;/strong&gt;（分散式追蹤），發現 Distributed Tracing 對於 Microservices 的維護與開發是非常好用且重要的技術。&lt;/p&gt;
&lt;p&gt;雖然 &lt;strong&gt;Loggi
      
    
    </summary>
    
    
    
      <category term="kubernetes" scheme="http://yoursite.com/tags/kubernetes/"/>
    
      <category term="distributed-tracing" scheme="http://yoursite.com/tags/distributed-tracing/"/>
    
      <category term="observability" scheme="http://yoursite.com/tags/observability/"/>
    
      <category term="opentelemetry" scheme="http://yoursite.com/tags/opentelemetry/"/>
    
  </entry>
  
  <entry>
    <title>使用 VS Code + Oketo 在 Kubernetes 遠端開發 - 以 Python 為例</title>
    <link href="http://yoursite.com/2020/06/21/okteto-vscode-python/"/>
    <id>http://yoursite.com/2020/06/21/okteto-vscode-python/</id>
    <published>2020-06-21T23:30:46.000Z</published>
    <updated>2020-07-26T22:13:20.769Z</updated>
    
    <content type="html"><![CDATA[<p>本文介紹如何使用 VS Code 上的 <a href="https://marketplace.visualstudio.com/items?itemName=okteto.remote-kubernetes" target="_blank" rel="noopener">Remote - Kubernetes</a> (Okteto) 插件來在 K8S Cluster 內遠端開發 Python application。</p><p>（本文的範例程式碼也可以在 GitHub 找到：<a href="https://github.com/lockercho/okteto-python-example" target="_blank" rel="noopener">https://github.com/lockercho/okteto-python-example</a> ）</p><h2 id="Okteto-介紹"><a class="header-anchor" href="#Okteto-介紹"></a>Okteto 介紹</h2><p>Okteto 這個工具會幫你在 Kubernetes 設定好開發用的 deployment、同步檔案至遠端、以及設定完成後自動開啟 Remote-SSH 連線至遠端環境。</p><h2 id="為什麼要使用遠端開發？"><a class="header-anchor" href="#為什麼要使用遠端開發？"></a>為什麼要使用遠端開發？</h2><p>假設使用這個開發中的 application 未來也會 deploy 在 k8s cluster 上，遠端開發可以提供以下好處：</p><ul><li>不用再多準備一份差很大 local config：在開發時可以直接使用 cluster config（儘管這份 config 可能是 dev 環境的，通常也會比 local config 更接近 production 環境）。</li><li>若開發的 application 依賴於 k8s 內的多個其他 service，直接在 cluster 內開發可以省去很多額外的 port forward 設定。</li><li>邪惡 debug 之術 😈：若使用運行中的 deployment 的名稱來建立環境，則 Okteto 會暫時取代掉原本的 deployment，開發結束才換回來（千萬別用在 production 環境，除非你百分之兩億知道自己在做什麼。)</li></ul><p>接下來就開始手把手講解如何建立一個 Kubernetes 內開發環境。</p><h2 id="設定流程"><a class="header-anchor" href="#設定流程"></a>設定流程</h2><h3 id="Step-1-準備一個-K8S-Cluster"><a class="header-anchor" href="#Step-1-準備一個-K8S-Cluster"></a>Step 1: 準備一個 K8S Cluster</h3><p>要設定 K8S 遠端開發，首先要準備一個你有權限跑 <code>kubectl apply</code> 的 K8S cluster。</p><p>如果沒有的話，<a href="https://cloud.okteto.com/#/login" target="_blank" rel="noopener">Okteto Cloud</a> 提供了免費的 cluster 可以使用，只要使用 GitHub 帳號註冊即可。（本文是使用 Mac OS X 上的 Docker Desktop 內建的 Kubernetes）</p><h3 id="Step-2-安裝-VS-Code-的-Remote-Kubernetes-Extension"><a class="header-anchor" href="#Step-2-安裝-VS-Code-的-Remote-Kubernetes-Extension"></a>Step 2: 安裝 VS Code 的 Remote - Kubernetes Extension</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=okteto.remote-kubernetes" target="_blank" rel="noopener">Remote - Kubernetes</a></p><h3 id="Step-3-設定-Okteto-yaml"><a class="header-anchor" href="#Step-3-設定-Okteto-yaml"></a>Step 3: 設定 Okteto.yaml</h3><p>假設現在在開發一個 Python 的 hello-world 專案，你需要建立一個 <code>hello-world/okteto.yml</code> 檔案，內容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># name 會是開發用的 deployment name</span><br><span class="line">name: hello-world</span><br><span class="line"></span><br><span class="line"># 使用 Okteto 提供的 Python Image</span><br><span class="line">image: okteto&#x2F;python:3-dev</span><br><span class="line"></span><br><span class="line">command: [&quot;bash&quot;]</span><br><span class="line"></span><br><span class="line"># Source Code 會被同步至這個 dir</span><br><span class="line">workdir: &quot;&#x2F;opt&#x2F;src&#x2F;&quot;</span><br><span class="line"></span><br><span class="line"># 設定將遠端 port 5000 forward 到本機 port 25000，等等會用到</span><br><span class="line">forward:</span><br><span class="line">  - 25000:5000</span><br></pre></td></tr></table></figure><h3 id="Step-3-啟動遠端開發環境"><a class="header-anchor" href="#Step-3-啟動遠端開發環境"></a>Step 3: 啟動遠端開發環境</h3><p>接著 Cmd + Shift + p 開啟 Command Palette 使用 <code>Okteto: Up</code></p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/okteto-up.png" width="400px" title="Okteto Starting..."></div><p>再選擇你剛剛建立的 <code>hello-world/okteto.yaml</code> 設定檔。</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/okteto-select-manifest.png" width="400px" title="Okteto Starting..."></div><br/>選完設定檔後 VS Code 右下角會跳出提示正在準備你的 Remote 開發環境：<div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/okteto-starting.png" width="400px" title="Okteto Starting..."></div><p>環境建立好後 terminal 會顯示以下訊息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ✓  Development container activated</span><br><span class="line"> ✓  Files synchronized</span><br><span class="line">    Namespace: default</span><br><span class="line">    Name:      python-okteto-sample</span><br><span class="line">    SSH:       22100 -&gt; 2222</span><br><span class="line">    Forward:   25000 -&gt; 5000</span><br><span class="line"></span><br><span class="line">Welcome to your development environment. Happy coding!</span><br><span class="line">okteto&gt;</span><br></pre></td></tr></table></figure><p>同時 VS Code 會開啟一個新的視窗，可以看到上面中間的標題與左下狀態都有標記 [SSH: XXX.okteto] 代表這個視窗是遠端環境：</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/vscode-remote-welcome.png" width="800px" title="Okteto Starting..."></div><h3 id="Step-4-設定-Python-環境"><a class="header-anchor" href="#Step-4-設定-Python-環境"></a>Step 4: 設定 Python 環境</h3><p>由於這個遠端是一個乾淨環境，所以需要重新安裝 Python 開發套件並 reload。</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/vscode-install-python-small.png" width="400px" title="Okteto Starting..."></div><p>接著選擇 Debugger 要使用的 Python Interpreter，Okteto 預設會幫你開一個 python <code>venv</code> 資料夾，但如果在 TERMINAL 下 <code>which python</code> 會發現是使用 <code>/usr/local/bin/python</code> 而非 <code>venv/bin/python</code>。這邊為了讓 debugger 方便抓到 pip 安裝的套件，我直接把 Interpreter 設定為 <code>/usr/local/bin/python</code>。</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/vscode-select-interpreter.png" width="800px" title="VS Code: select interpreter"></div><br><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/vscode-select-python-version.png" width="800px" title="VS Code: select interpreter"></div><p>接著使用 <code>Cmd +j</code> 叫出 VS Code TERMINAL，跑 <code>pip install Flask==1.1.2</code> 安裝 Flask</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/flask-install.png" width="800px" title="Install flask"></div><h3 id="Step-5-建立測試用的-Python-application"><a class="header-anchor" href="#Step-5-建立測試用的-Python-application"></a>Step 5: 建立測試用的 Python application</h3><p>接下來用 Flask 建立一個簡單的測試 app。</p><p>建立 <code>app.py</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;hello&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;World!&quot;</span><br></pre></td></tr></table></figure><p>建立 <code>.vscode/launch.json</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Python: Flask&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;python&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;module&quot;: &quot;flask&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;</span><br><span class="line">                &quot;FLASK_APP&quot;: &quot;app.py&quot;,</span><br><span class="line">                &quot;FLASK_ENV&quot;: &quot;development&quot;,</span><br><span class="line">                &quot;FLASK_DEBUG&quot;: &quot;0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;run&quot;,</span><br><span class="line">                &quot;--no-debugger&quot;,</span><br><span class="line">                &quot;--no-reload&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定完了就可以使用 VS Code menu 的 <code>Run -&gt; Start Debugging</code> 或 <code>F5</code> 開始 debug。<br>此時可以順便在 <code>line 7</code> 設定一個測試用的中斷點：</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/python-run-success.png" width="800px" title="Install flask"></div><p>由於一開始有設定了 Okteto 把 remote 的 <code>5000</code> port forward 到本機的 <code>25000</code> port，現在可以從 <code>localhost:25000</code> 測試剛剛寫的 <code>/hello</code> 這個 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:25000&#x2F;hello</span><br></pre></td></tr></table></figure><p>如果剛剛設定了中斷點，應該會發現這個 curl 不會 return。切回 remote VS Code 視窗會發現中斷點被成功觸發了：</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/python-breakpoint-success.png" width="800px" title="Install flask"></div><p>到這邊就成功設定且測試我們的 Remote Python 開發環境了 👍</p><h2 id="Trouble-Shooting-疑難排解"><a class="header-anchor" href="#Trouble-Shooting-疑難排解"></a>Trouble Shooting 疑難排解</h2><p>筆者在使用<code>Remote - Kubernetes</code> 遠端開發時經常遇到 <code>Okteto: Up</code> 指令失敗、逾時，或是雖然指令成功，卻沒有連上遠端環境等狀況，這時會需要分段檢查環境問題。</p><h3 id="可能性一：遠端環境及-ssh-連線正常，只是-VS-Code-沒有自動連上"><a class="header-anchor" href="#可能性一：遠端環境及-ssh-連線正常，只是-VS-Code-沒有自動連上"></a>可能性一：遠端環境及 ssh 連線正常，只是 VS Code 沒有自動連上</h3><p>這時可以先試著使用 Remote-SSH 連回遠端。<code>Cmd + Shift + P</code> 開啟 Command Palette，選擇 <code>Remote-SSH: Connect to Host</code>：</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/remote-ssh-connect.png" width="400px" title="Install flask"></div><p>再選擇要連線的遠端環境：</p><div style="width:100%; text-align:center;"><img src="/blog/2020/06/21/okteto-vscode-python/remote-ssh-select-host.png" width="400px" title="Install flask"></div><h3 id="可能性二：SSH-連線失效"><a class="header-anchor" href="#可能性二：SSH-連線失效"></a>可能性二：SSH 連線失效</h3><p>若直接使用 Remote-SSH 無法連回遠端，則需使用 <code>Okteto: Down</code> Deactivate 目前環境，再用 <code>Okteto: Up</code> 重開。有時候會發生 <code>Okteto: Down</code> 顯示成功，但 <code>Okteto: Up</code> 失敗的狀況，必須多跑幾次後才能再次使用 <code>Okteto: Up</code>。</p><h3 id="可能性三：其他-Okteto-Error"><a class="header-anchor" href="#可能性三：其他-Okteto-Error"></a>可能性三：其他 Okteto Error</h3><p>Okteto 預設會寫 log 進 <code>~/.okteto/okteto.log</code>，可以看到詳細的錯誤訊息，見招拆招。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail ~&#x2F;.okteto&#x2F;okteto.log</span><br></pre></td></tr></table></figure><h2 id="其他設定方式"><a class="header-anchor" href="#其他設定方式"></a>其他設定方式</h2><p>我自己測試有一部分的問題是來自於 <code>Remote - Kubernetes</code> 這個插件沒有正確的 launch 遠端環境或設定 port。</p><p>另外 <code>Remote - Kubernetes</code> 有另一個很大的限制是一次只能 launch 一個遠端開發環境 (GitHub 上有發相關的 <a href="https://github.com/okteto/remote-kubernetes/issues/101" target="_blank" rel="noopener">issue</a>)。我觀察這是因為 <code>Okteto: Up</code> 這個指令在 command line 寫死了 <code>--remote 22100</code>，即使在 <code>okteto.yml</code> 設定了別的 <code>remote</code>，VS Code 插件這邊也會直接無視，希望之後官方會處理這個 bug。</p><p>因為上述的種種不穩問題，我現在都是自己分兩段設定：</p><ol><li>直接用 <a href="https://okteto.com/docs/reference/cli/index.html" target="_blank" rel="noopener">Okteto CLI</a>，先在 terminal 下  <code>okteto up -f ./okteto.yml</code> 確定環境成功跑起</li><li>再用 <code>VS Code Remote SSH</code> 連上遠端環境（也就是 trouble shooting #1 的方式。）</li></ol><p>兩段式用法有一個比較直接的缺點是，連上遠端後 VS Code 不會自動 cd 進 <code>okteto.yml</code> 裡設定的 <code>workdir</code>，而是會進到 <code>/root/</code>，要自己從 VS Code Side Bar 再切過去。</p><p>而前面也有說過其實 <code>Remote - Kubernetes</code> 就是 <code>Okteto</code> + <code>Remote-SSH</code>，所以若採用了這個兩段式用法，基本上可以直接移除 <code>Remote - Kubernetes</code> 了 XDDD<br><br/></p><h2 id="結語"><a class="header-anchor" href="#結語"></a>結語</h2><p>本文簡單介紹了如何使用 Okteto 的 <code>Remote - Kubernetes</code> VS Code extension 來建立 Kubernetes 中的 Python 開發環境。</p><p>除了本文介紹的部分以外，Okteto 其實有提供了更多的選項可以設定，包含了設定環境變數、限制 resources、設定多個 port、、設定 secrets 及 PersistentVolume 等等，詳細可以看官方的 <a href="https://okteto.com/docs/reference/manifest/index.html" target="_blank" rel="noopener">Manifest Reference</a></p><p>遠端開發對相依於 K8S cluster 的 application 來說相當方便，但因為需要事前設定，我自己開發 API 時還是會先以本機開發 + fake data 為主，直到主要邏輯開發完畢後才放上 development cluster 測試，並搭配中斷點快速修正早期問題。但同事也有人是以 Remote 開發為主（請搭配 <a href="https://okteto.com/docs/reference/manifest/index.html#persistentvolume-object-optional" target="_blank" rel="noopener">persistentVolume</a> 設定服用，否則每次光 Sync files 就要等半天…）。本機與遠端開發的選擇很看個人偏好，用的順手最重要囉。</p><h2 id="參考資料"><a class="header-anchor" href="#參考資料"></a>參考資料</h2><ul><li><a href="https://medium.com/okteto/remote-kubernetes-development-in-visual-studio-code-with-okteto-8b96015b41a6" target="_blank" rel="noopener">Remote Kubernetes Development in Visual Studio Code with Okteto (Golang)</a></li><li><a href="https://okteto.com/blog/how-to-develop-python-apps-in-kubernetes/" target="_blank" rel="noopener">How to Develop and Debug Python Applications in Kubernetes (using PyCharm)</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=okteto.remote-kubernetes" target="_blank" rel="noopener">VS Code Remote - Kubernetes</a></li><li><a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">VS Code Remote - SSH</a></li><li><a href="https://okteto.com/docs/reference/manifest/index.html" target="_blank" rel="noopener">Okteto Manifest Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介紹如何使用 VS Code 上的 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=okteto.remote-kubernetes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python 3.9 有哪些新玩意？</title>
    <link href="http://yoursite.com/2020/06/20/whats-new-in-python-39/"/>
    <id>http://yoursite.com/2020/06/20/whats-new-in-python-39/</id>
    <published>2020-06-20T15:41:08.000Z</published>
    <updated>2020-07-26T22:13:20.781Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.python.org/3.9/whatsnew/3.9.html" target="_blank" rel="noopener">Python 3.9</a> 即將在今年 10 月初 release，本文介紹一些 Python 3.9 的新東西。</p><h2 id="New-Features"><a class="header-anchor" href="#New-Features"></a>New Features</h2><h3 id="Dictionary-Merge-Update-Operators"><a class="header-anchor" href="#Dictionary-Merge-Update-Operators"></a>Dictionary Merge &amp; Update Operators</h3><p>Dictionary 引進新的 operator <code>|</code>，可以方便的 merge 與 update dictionary。<br>以下範例扣比較新舊語法的差異：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#123;&quot;a_key&quot;: &quot;a_value&quot;&#125;</span><br><span class="line">b &#x3D; &#123;&quot;b_key&quot;: &quot;b_value&quot;&#125;</span><br><span class="line"></span><br><span class="line"># Before 3.9</span><br><span class="line">merged &#x3D; &#123;**a, **b&#125;</span><br><span class="line"></span><br><span class="line"># &gt;&#x3D; 3.9</span><br><span class="line">merged &#x3D; a | b</span><br></pre></td></tr></table></figure><p>如果是要把 dict b 的內容 update 進 dict a：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Before 3.9</span><br><span class="line">a.update(b)  # a 的內容被更新，update() return None</span><br><span class="line"></span><br><span class="line"># &gt;&#x3D; 3.9</span><br><span class="line">a |&#x3D; b</span><br></pre></td></tr></table></figure><p>可以看到新的語法更加乾淨直覺。</p><h3 id="Typing-Builtin-Generic-Types-PEP-585"><a class="header-anchor" href="#Typing-Builtin-Generic-Types-PEP-585"></a>Typing: Builtin Generic Types <a href="https://www.python.org/dev/peps/pep-0585/" target="_blank" rel="noopener">(PEP 585)</a></h3><p>名詞定義：</p><ul><li>Generic 指的是可以被參數化的型別，通常是容器，用 <code>Dict</code>, <code>List</code> 來想像就可以了。</li><li>Parameterized Generic 就是已指定參數的 Generic，例如 <code>Dict[str, int]</code>。</li></ul><p>原本在做 typing hint 時，會需要從 typing module 額外 import 大寫的 <code>Dict</code>, <code>Tuple</code>, <code>List</code> 或 <code>Set</code> 來宣告你需要的 Parameterized Generic。這是因為 builtin 的小寫 <code>list</code>, <code>dict</code> 不具備 Generic 的功能（使用 <code>list[str]</code> 會報 <code>TypeError: 'type' object is not subscriptable</code>。）</p><p>在 Python 3.7 後可以藉由 <code>from __future__ import annotations</code> 來使用 <code>list[str]</code>。</p><p>而這次在 Python 3.9 後就是直接原生支援了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Before 3.7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; #</span><br><span class="line"></span><br><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line">def method() -&gt; List[str]:</span><br><span class="line">    return [&quot;hola&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Python 3.7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; #</span><br><span class="line"></span><br><span class="line">from __future__ import annotations</span><br><span class="line"></span><br><span class="line">def method() -&gt; list[str]:</span><br><span class="line">    return [&quot;hola&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Python 3.9 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; #</span><br><span class="line"></span><br><span class="line">def method() -&gt; list[str]:</span><br><span class="line">    return [&quot;hola&quot;]</span><br></pre></td></tr></table></figure><p>這次更新以後小寫的 <code>tuple</code>, <code>list</code>, <code>dict</code>, <code>set</code>, <code>frozenset</code>, <code>type</code> 等等都原生支援 Generic 了，詳細列表可以參考<a href="https://www.python.org/dev/peps/pep-0585/#implementation" target="_blank" rel="noopener">這裡</a>。</p><p>我自己原本的用法是，需要 Generic 時才 import 大寫，不需 Generic 時用原生小寫。但時常發 PR 時會被 comment 説請改用大寫的（因為公司沒有明確規範 typing 這邊的 style），不過這版以後全都小寫就好囉。</p><h3 id="String-removeprefix-removesuffix"><a class="header-anchor" href="#String-removeprefix-removesuffix"></a>String: removeprefix, removesuffix</h3><p>String 多了兩個小 helper function，可以拿來處理移除前綴後綴：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;TestHook&quot;.removeprefix(&quot;Test&quot;)  # &#x3D;&gt; &quot;Hook&quot;</span><br><span class="line">&quot;BaseTestCase&quot;.removeprefix(&quot;Test&quot;) # &#x3D;&gt; &quot;BaseTestCase&quot;</span><br><span class="line"></span><br><span class="line">&quot;MiscTests&quot;.removesuffix(&quot;Tests&quot;) # &#x3D;&gt; &quot;Misc&quot;</span><br><span class="line">&quot;TmpDirMixin&quot;.removesuffix(&quot;Tests&quot;) # &#x3D;&gt; &quot;TmpDirMixin&quot;</span><br></pre></td></tr></table></figure><h3 id="Decorator-Syntax-Update-PEP-614"><a class="header-anchor" href="#Decorator-Syntax-Update-PEP-614"></a>Decorator Syntax Update <a href="https://www.python.org/dev/peps/pep-0614/" target="_blank" rel="noopener">(PEP 614)</a></h3><p>這個改動放寬了 decorator 的語法限制。目前 decorator 的語法裡面不能帶太多的 expression，以下是 PEP 裡面給出的 PyQt 範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buttons &#x3D; [QPushButton(f&#39;Button &#123;i&#125;&#39;) for i in range(10)]</span><br><span class="line"></span><br><span class="line"># Do stuff with the list of buttons...</span><br><span class="line"></span><br><span class="line">@buttons[0].clicked.connect</span><br><span class="line">def spam():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>以上的語法是不合法的，必須改寫為以下才能動：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button_0 &#x3D; buttons[0]</span><br><span class="line"></span><br><span class="line">@button_0.clicked.connect</span><br><span class="line">def spam():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>但神奇的是可以使用一些 hack 來達成在 decorator 使用複雜的 expression：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Hack option 1: Identity function:</span><br><span class="line"></span><br><span class="line">def _(x):</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">@_(buttons[0].clicked.connect)</span><br><span class="line">def spam():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"># Hack option 2: eval:</span><br><span class="line"></span><br><span class="line">@eval(&quot;buttons[1].clicked.connect&quot;)</span><br><span class="line">def eggs():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>PEP 614 中有提到，雖然 motivation 範例的需求是 subscripting（i.e. 使用 <code>[0]</code> 取用），但與其隨意放寬單一語法，不如直接放寬到允許 <code>expression</code>。在這裡的 <code>expression</code> 指的是任何可以放在 <code>if</code>, <code>elif</code> 或 <code>while</code> 裡做判斷的東西。</p><p>總之以上面的範例來說，以後可以直接寫成這樣了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttons &#x3D; [QPushButton(f&#39;Button &#123;i&#125;&#39;) for i in range(10)]</span><br><span class="line"></span><br><span class="line">@buttons[0].clicked.connect</span><br><span class="line">def spam():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="New-Updated-Module"><a class="header-anchor" href="#New-Updated-Module"></a>New / Updated Module</h2><h3 id="zoneinfo-PEP-615"><a class="header-anchor" href="#zoneinfo-PEP-615"></a>zoneinfo <a href="https://www.python.org/dev/peps/pep-0615/" target="_blank" rel="noopener">(PEP 615)</a></h3><p>zoneinfo 這個 module 在 Python 3.9 被加入了 standard modules 裡面。</p><p>以前在台灣工作時其實很少需要處理時區問題，只要把握好 server side 都用 timestamp 或 UTC time，顯示時間、轉換格式都在 client side 處理的原則，幾乎沒有出過問題。</p><p>而現在在倫敦的工作有大量的 timezone 問題需要處理。主要原因是英國有日光節約時間，冬季是 GMT+0、夏季是 GMT+1，加上在能源產業，雖然公司是新創公司，但有大量資料要跟業界舊的系統或人工業務對接，導致許多 input data 的時間都是用 local time，同個 time string <code>13:00</code> 在夏季跟冬季會使用不同的 timezone offset。最要命的是，在進入冬季的 clock change day 時，時鐘會往回調，所以這天的 local time 會有兩種 <code>02:00</code>。</p><p>為了處理時區，目前公司用的是 <code>pytz</code> 這個 module，未來升級 Python 3.9 時改用 <code>zoneinfo</code> 就不用額外安裝了。另外<a href="https://www.python.org/dev/peps/pep-0615/#using-a-pytz-like-interface" target="_blank" rel="noopener">這裡</a> 也討論了為什麼是放 <code>zoneinfo</code> 進 standard 而不是 <code>pytz</code>。</p><h2 id="New-Parser-PEP-617"><a class="header-anchor" href="#New-Parser-PEP-617"></a>New Parser <a href="https://www.python.org/dev/peps/pep-0617/" target="_blank" rel="noopener">(PEP 617)</a></h2><p>Python 3.9  把 CPython 的 LL(1) parser 換成 PEG parser。</p><p>文件裡寫到 PEG parser 的效能跟原本的 parser 差不多，並且會生成一樣的 AST。這個改動從使用者角度上應該感受不到差異，主要目的是在開發語言的新 feature 時，PEG parser 提供了更多的彈性。而 PEP 617 也提到了本來他們有對 LL(1) parser 做了一些 hack，改用 PEG parser 後就不用繼續 maintain 這些 hack 了。</p><h2 id="結語"><a class="header-anchor" href="#結語"></a>結語</h2><p>以上是筆者從自己的角度整理出 Python 3.9 比較值得一提的新功能，但當然也可能有些我沒有用到的 feature 對別人來說其實是很重要的改動，所以一樣推薦直接<a href="https://docs.python.org/3.9/whatsnew/3.9.html" target="_blank" rel="noopener">閱讀原文</a>。</p><p>（另外因為官方文件還在草稿階段所以會持續更新，建議 release 時可以再回去看一下。）</p><h2 id="Reference"><a class="header-anchor" href="#Reference"></a>Reference</h2><ul><li><a href="https://docs.python.org/3.9/whatsnew/3.9.html" target="_blank" rel="noopener">官方文件：What’s New In Python 3.9</a></li><li><a href="https://www.python.org/dev/peps/pep-0585/" target="_blank" rel="noopener">PEP 585 – Type Hinting Generics In Standard Collections</a></li><li><a href="https://www.python.org/dev/peps/pep-0614/" target="_blank" rel="noopener">PEP 614 – Relaxing Grammar Restrictions On Decorators</a></li><li><a href="https://www.python.org/dev/peps/pep-0615/" target="_blank" rel="noopener">PEP 615 – Support for the IANA Time Zone Database in the Standard Library</a></li><li><a href="https://www.python.org/dev/peps/pep-0617/" target="_blank" rel="noopener">PEP 617 – New PEG parser for CPython</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.python.org/3.9/whatsnew/3.9.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python 3.9&lt;/a&gt; 即將在今年 10 月初 release，本文介紹一些 Python 3
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 尬設計模式：沒有 Interface，但有 abc</title>
    <link href="http://yoursite.com/2020/06/17/python-interface-use-abc/"/>
    <id>http://yoursite.com/2020/06/17/python-interface-use-abc/</id>
    <published>2020-06-17T22:07:34.000Z</published>
    <updated>2020-07-26T22:13:20.781Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章用來記錄我在工作上寫 Python 時使用 Design Pattern 的一些心得。</p><p>Python 不是一個典型的 OOP 語言（相對於 Java 而言），要用 Python 寫 OOP 時難免有些卡卡的。如果你跟我一樣先從別的語言（Java, C++, …）學過 Design Pattern 了，現在想把知識拉到 Python 用卻不知道從何下手，這篇文章可能會對你有些幫助。</p><p>（另外，本文預設讀者已經懂 OOP、Design Pattern、Interface 與 Python）<br>（如果沒有先行知識，這篇文章可能會讓你看得很混淆，慎入！）</p><h2 id="Python-沒有-Interface"><a class="header-anchor" href="#Python-沒有-Interface"></a>Python 沒有 Interface</h2><p>Design Pattern 經常需要使用 Interface 來達成多型。Python 原生沒有 Interface，但還是有些方法可以做出 Interface。</p><h3 id="Option-1-Interface-是啥？我有多重繼承！"><a class="header-anchor" href="#Option-1-Interface-是啥？我有多重繼承！"></a>Option 1: Interface 是啥？我有多重繼承！</h3><p>Python 可以多重繼承，基本上可以寫一堆 class 叫做 XxxInterface，然後多重繼承這些 class 就好。不過這樣的寫法會重用 Super class 的實作，跟 Interface 的主功能：定義需要的 property/method/input/output 而不實作，還是有一點點差異。</p><h3 id="Option-2-abc-Abstract-Base-Class"><a class="header-anchor" href="#Option-2-abc-Abstract-Base-Class"></a>Option 2: abc (Abstract Base Class)</h3><p>要更 fancy 的話， 用 abc 這個 <sub>名字有點鬧的</sub> module 可以寫出更接近 “Interface” 的東西。</p><p>要定義一個 Interface，你需要寫一個 class 繼承 <code>abc.ABC</code>，並把 <code>abstract method</code> 跟 <code>abstract property</code> decorate 好，這就是你的 Interface。要實作這個 Interface 時用繼承的就好。</p><p>以下是範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import abc</span><br><span class="line"></span><br><span class="line"># 定義 Interface</span><br><span class="line"></span><br><span class="line">class BookInterface(abc.ABC):</span><br><span class="line">    # 定義 read-only property</span><br><span class="line">    @abstractproperty</span><br><span class="line">    def author(self):</span><br><span class="line">        return self.__author</span><br><span class="line"></span><br><span class="line">    # 定義 read-write abstract property</span><br><span class="line">    def getp(self):</span><br><span class="line">        return self.__price</span><br><span class="line"></span><br><span class="line">    def setp(self, value):</span><br><span class="line">        self.__price &#x3D; value</span><br><span class="line"></span><br><span class="line">    price &#x3D; abc.abstractproperty(getp, setp)</span><br><span class="line"></span><br><span class="line">    # 定義 abstract method</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def read(self):</span><br><span class="line">        print(&quot;Interface Impl&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 繼承（實作） BookInterface</span><br><span class="line"></span><br><span class="line">class AmazonEbook(BookInterface):</span><br><span class="line">    @property</span><br><span class="line">    def price(self):</span><br><span class="line">        return self.__price</span><br><span class="line"></span><br><span class="line">    @price.setter</span><br><span class="line">    def price(self, value):</span><br><span class="line">        self.__price &#x3D; value</span><br><span class="line"></span><br><span class="line">    def read(self):</span><br><span class="line">        print(&quot;AmazonEbook read&quot;)</span><br></pre></td></tr></table></figure><p>上面抄走就可以開始寫 Interface 囉！</p><p>\OOP/ \Design Pattern/ \Polymorphism/ 尬起來！</p><h4 id="Abstract-Base-Class-提供的好處"><a class="header-anchor" href="#Abstract-Base-Class-提供的好處"></a>Abstract Base Class 提供的好處</h4><p>如前面所說，多重繼承其實就可以處理基本的 Interface 問題了，而相對於用多重繼承硬尬，ABC 還多提供了以下輔助：</p><ol><li><p>如果少 implement 了 abstract method 或 abstract property，Object initialization 時會報 <code>TypeError</code>。</p></li><li><p>使用 abc 可以 overload <code>__subclasscheck__</code>, <code>__instancecheck__</code>，讓你有機會改變 <code>issubclass()</code> 跟  <code>isinstance()</code> 的預設行為。</p></li></ol><p>另外還有些好處可能跟 extend / implement 一些 built-in Type 如 Sets, Sequences 有關，但這部分我不熟所以就不多做介紹以免誤導，有興趣的人可以看看 <a href="https://www.python.org/dev/peps/pep-3119/" target="_blank" rel="noopener">PEP 3119</a>。</p><h4 id="Abstract-Base-Class-依舊不是-Interface"><a class="header-anchor" href="#Abstract-Base-Class-依舊不是-Interface"></a>Abstract Base Class 依舊不是 Interface</h4><p>拿 abc 當 Interface 用，寫一寫可能還是會發現哪裡怪怪的。<br>這邊列了一些從 Interface 轉來的人會覺得 abc</p><ol><li>如果少 implement 了什麼 method，會到 init object 才噴錯。這算是 Python 的原罪，可以使用 Pylint 之類的 linter 自動找出沒 implement 的 method 來處理掉這個問題。</li><li>abstract method <strong><em>可以</em></strong> 有 concrete implementation，並能用 super() 取用：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class SimpleInterface(abc.ABC):</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def method_a(self):</span><br><span class="line">        print(&quot;I&#39;m from an Interface.&quot;)</span><br><span class="line"></span><br><span class="line">class SimpleConcrete(SimpleInterface):</span><br><span class="line">    def method_a(self):</span><br><span class="line">        super().method_a()</span><br><span class="line"></span><br><span class="line">SimpleConcrete().method_a() # 會印出 &quot;I&#39;m from an Interface.&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Implement abstract method 時，arguments 名稱跟數量都可以不一樣。（但有的 linter 會提示你請取一樣的名稱）</p></li><li><p>甚至也 <strong><em>可以</em></strong> 用 property implement method 或用 method implement property。<br>（畢竟 Python 是 first class function，大家都是 object）<br>（只是 call 錯時還是會噴錯就是了XD）</p></li></ol><h2 id="但我聽說-Python-是-Duck-Typing-所以根本不用-Interface？"><a class="header-anchor" href="#但我聽說-Python-是-Duck-Typing-所以根本不用-Interface？"></a>但我聽說 Python 是 Duck Typing 所以根本不用 Interface？</h2><p><a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">Duck Typing</a>（鴨子型別）的意思是：「當看到一隻鳥走起來像鴨子、游泳起來像鴨子、叫起來也像鴨子，那麼這隻鳥就可以被稱為鴨子。」<br>也就是說一個 class 不管他實際上繼承自哪，只要有相應的 method/property，Python 就允許這個 class 到處 <sub>招搖撞騙</sub> 被當作其他特定 class 使用。</p><p>abc 的作者也在 PEP-3119 有一段 <a href="https://www.python.org/dev/peps/pep-3119/#abcs-vs-duck-typing" target="_blank" rel="noopener">ABCs v.s Duck Typing 的討論</a>。大意是說 abc 不是拿來殺害 Duck Typing 的。很多時候只要使用 <code>hasattr()</code> 來判斷需要的 attribute 存在就已經寫的 666 了，那就不一定要使用 abc。</p><p>其實我自己覺得 Python 的 Duck Typing 跟多重繼承，合起來是 self-contained 的一套了。至少在 2007 年以前 abc 都不存在，與其尋找類 Interface 的替代品，不如深入了解 Python 語言本身的強項/限制/理念，來找出情境下最合適的寫法。雖然我在上面列了一些 abc 會讓人感到「怪怪的」點，但再稍微思考一下，那些點都不是 abc 故意設計的，而是 Python 本身特性自然造就的而已。</p><p>就算到今日 abc 已經很成熟，何時使用 abc、如何使用也都該交由使用情境來決定，總之就是沒有銀彈。</p><p>最後推薦閱讀本文不斷出現的 <a href="https://www.python.org/dev/peps/pep-3119/" target="_blank" rel="noopener">PEP-3119</a>，這是當初 Python 社群提出 abc 的 proposal。裡面詳細寫了為什麼要有 abc、相關用法以及跟其他 alternatives 的比較討論。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章用來記錄我在工作上寫 Python 時使用 Design Pattern 的一些心得。&lt;/p&gt;
&lt;p&gt;Python 不是一個典型的 OOP 語言（相對於 Java 而言），要用 Python 寫 OOP 時難免有些卡卡的。如果你跟我一樣先從別的語言（Java, 
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="oop" scheme="http://yoursite.com/tags/oop/"/>
    
      <category term="design-pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
  </entry>
  
</feed>
